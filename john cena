<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tetris — Play in your browser</title>
<style>
  :root{ --bg:#0b1220; --panel:#0f1724; --accent:#22c1c3; --muted:#9aa4b2; }
  body{ margin:0; font-family:system-ui, -apple-system, "Segoe UI", Roboto, Arial; background:var(--bg); color:#e6eef6; display:flex; align-items:center; justify-content:center; height:100vh; }
  .wrap{ display:flex; gap:18px; align-items:flex-start; padding:18px; }
  .board{ background:#07101a; padding:8px; border-radius:8px; box-shadow: 0 6px 18px rgba(0,0,0,0.6); }
  canvas{ display:block; background:linear-gradient(180deg,#07101a, #06202a); border-radius:6px; }
  .panel{ width:220px; background:var(--panel); padding:12px; border-radius:8px; }
  h1{ margin:0 0 8px 0; font-size:18px; }
  .info{ font-size:14px; color:var(--muted); margin-bottom:8px; }
  .big{ font-size:20px; font-weight:700; margin:6px 0; }
  .row{ display:flex; justify-content:space-between; align-items:center; gap:8px; }
  button{ background:var(--accent); border:none; color:#042428; padding:8px 10px; border-radius:8px; font-weight:700; cursor:pointer; }
  .controls{ display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
  .mobile-controls{ display:none; margin-top:10px; gap:8px; }
  .hint{ font-size:12px; color:var(--muted); margin-top:6px; }
  @media (max-width:820px){
    body{ align-items:flex-start; padding:18px 6px; }
    .wrap{ flex-direction:column; align-items:center; }
    .mobile-controls{ display:flex; }
  }
  /* small buttons */
  .small{ padding:6px 8px; font-size:13px; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="board">
      <canvas id="game" width="240" height="480"></canvas>
    </div>

    <div class="panel">
      <h1>Tetris — Browser</h1>
      <div class="info">Controls: ← → rotate ⤴ soft drop ↓ hard drop space pause</div>
      <div class="row"><div>Score</div><div id="score" class="big">0</div></div>
      <div class="row"><div>Level</div><div id="level" class="big">1</div></div>
      <div class="row"><div>Lines</div><div id="lines" class="big">0</div></div>
      <div class="hint">Mobile: use on-screen buttons below (shown on small screens).</div>
      <div class="controls" style="margin-top:10px;">
        <button id="startBtn" class="small">New Game</button>
        <button id="pauseBtn" class="small">Pause</button>
        <button id="toggleSound" class="small">Sound On</button>
      </div>

      <div style="margin-top:12px;">
        <div style="font-size:13px;color:var(--muted);">Next</div>
        <canvas id="next" width="80" height="80" style="background:#051218; border-radius:6px; margin-top:6px"></canvas>
      </div>

      <div class="mobile-controls" style="margin-top:12px;">
        <button id="leftBtn" class="small">←</button>
        <button id="rotateBtn" class="small">⤴</button>
        <button id="rightBtn" class="small">→</button>
        <button id="downBtn" class="small">↓</button>
        <button id="dropBtn" class="small">Drop</button>
      </div>

      <div style="margin-top:12px; font-size:12px; color:var(--muted)">
        Built-in simple Tetris. Works offline in browser. Tap New Game to start.
      </div>
    </div>
  </div>

<script>
// Tetris implementation (compact but functional)
// Grid is 10x20, each cell 24px -> canvas 240x480
const COLS = 10, ROWS = 20, BLOCK = 24;
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const nextCanvas = document.getElementById('next');
const nctx = nextCanvas.getContext('2d');

// Colors
const COLORS = {
  'I':'#22d3ee','J':'#6475ff','L':'#ffb86b','O':'#ffd23f','S':'#3ee86e','T':'#c77cff','Z':'#ff6b6b'
};

// Tetromino templates (rotation states)
const TETROMINOES = {
  'I': [[[0,1],[1,1],[2,1],[3,1]], [[2,0],[2,1],[2,2],[2,3]], [[0,2],[1,2],[2,2],[3,2]], [[1,0],[1,1],[1,2],[1,3]]],
  'J': [[[0,0],[0,1],[1,1],[2,1]], [[1,0],[2,0],[1,1],[1,2]], [[0,1],[1,1],[2,1],[2,2]], [[1,0],[1,1],[0,2],[1,2]]],
  'L': [[[2,0],[0,1],[1,1],[2,1]], [[1,0],[1,1],[1,2],[2,2]], [[0,1],[1,1],[2,1],[0,2]], [[0,0],[1,0],[1,1],[1,2]]],
  'O': [[[1,0],[2,0],[1,1],[2,1]]],
  'S': [[[1,0],[2,0],[0,1],[1,1]], [[1,0],[1,1],[2,1],[2,2]], [[1,1],[2,1],[0,2],[1,2]], [[0,0],[0,1],[1,1],[1,2]]],
  'T': [[[1,0],[0,1],[1,1],[2,1]], [[1,0],[1,1],[2,1],[1,2]], [[0,1],[1,1],[2,1],[1,2]], [[1,0],[0,1],[1,1],[1,2]]],
  'Z': [[[0,0],[1,0],[1,1],[2,1]], [[2,0],[1,1],[2,1],[1,2]], [[0,1],[1,1],[1,2],[2,2]], [[1,0],[0,1],[1,1],[0,2]]]
};

function makeEmptyGrid(){ return Array.from({length:ROWS}, ()=>Array(COLS).fill('')); }
let grid = makeEmptyGrid();

// Game state
let current = null, next = null, score=0, level=1, lines=0, dropInterval=800, dropTimer=0, lastTime=0, running=false, paused=false, soundOn=true;

// Utilities
function randPiece(){ const keys = Object.keys(TETROMINOES); return keys[Math.floor(Math.random()*keys.length)]; }
function spawnPiece(){ current = {type: next || randPiece(), rot:0, x:3, y:0}; next = null; if (!next) next = randPiece(); // ensure next exists
  // O piece spawn center adjust
  if (current.type==='O') current.x=4;
  if (!valid(current, current.x, current.y, current.rot)) {
    // game over
    running=false;
    alert('Game Over — score: ' + score);
  }
}

// Collision/valid
function valid(piece, x, y, rot){
  const shapes = TETROMINOES[piece.type];
  const shape = shapes[rot % shapes.length];
  for (let b of shape){
    const px = x + b[0], py = y + b[1];
    if (px < 0 || px >= COLS || py < 0 || py >= ROWS) return false;
    if (grid[py][px]) return false;
  }
  return true;
}

// Place piece
function place(piece){
  const shape = TETROMINOES[piece.type][piece.rot % TETROMINOES[piece.type].length];
  for (let b of shape){
    const px = piece.x + b[0], py = piece.y + b[1];
    if (py>=0 && py<ROWS && px>=0 && px<COLS) grid[py][px] = piece.type;
  }
  clearLines();
  current = null;
  if (!next) next = randPiece();
  spawnPiece();
}

// Clear full lines
function clearLines(){
  let removed=0;
  for (let y=ROWS-1;y>=0;y--){
    if (grid[y].every(c=>c!=='') ){
      grid.splice(y,1);
      grid.unshift(Array(COLS).fill(''));
      removed++;
      y++; // recheck same index as rows moved down
    }
  }
  if (removed>0){ 
    lines += removed; 
    score += (removed===1?100: removed===2?300: removed===3?500:800) * level;
    level = Math.floor(lines/10)+1;
    dropInterval = Math.max(100, 800 - (level-1)*60);
  }
}

// Drop one step
function stepDrop(){
  if (!current) return;
  if (valid(current, current.x, current.y+1, current.rot)) {
    current.y++;
  } else {
    place(current);
  }
}

// Hard drop
function hardDrop(){
  if (!current) return;
  while (valid(current, current.x, current.y+1, current.rot)) current.y++;
  place(current);
}

// Move and rotate
function move(dx){
  if (!current) return;
  if (valid(current, current.x+dx, current.y, current.rot)) current.x += dx;
}
function rotate(dir=1){
  if (!current) return;
  const newRot = (current.rot + dir + 100) % TETROMINOES[current.type].length;
  if (valid(current, current.x, current.y, newRot)) current.rot = newRot;
  else {
    // simple wall kicks: try left/right
    if (valid(current, current.x-1, current.y, newRot)) current.x-=1, current.rot=newRot;
    else if (valid(current, current.x+1, current.y, newRot)) current.x+=1, current.rot=newRot;
  }
}

// Rendering
function drawCell(x,y,color){
  ctx.fillStyle = color || '#04202a';
  ctx.fillRect(x*BLOCK+1, y*BLOCK+1, BLOCK-2, BLOCK-2);
  // subtle highlight
  ctx.strokeStyle = 'rgba(0,0,0,0.2)';
  ctx.strokeRect(x*BLOCK+1, y*BLOCK+1, BLOCK-2, BLOCK-2);
}

function render(){
  // clear
  ctx.clearRect(0,0,canvas.width, canvas.height);
  // draw grid cells
  for (let y=0;y<ROWS;y++){
    for (let x=0;x<COLS;x++){
      if (grid[y][x]) drawCell(x,y, COLORS[grid[y][x]]);
      else drawCell(x,y,'#071a22');
    }
  }
  // draw current piece
  if (current){
    const shape = TETROMINOES[current.type][current.rot % TETROMINOES[current.type].length];
    for (let b of shape){
      const px = current.x + b[0], py = current.y + b[1];
      if (py>=0) drawCell(px, py, COLORS[current.type]);
    }
  }
  // update stats
  document.getElementById('score').textContent = score;
  document.getElementById('level').textContent = level;
  document.getElementById('lines').textContent = lines;
  renderNext();
}

function renderNext(){
  nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
  nctx.fillStyle = '#051218';
  nctx.fillRect(0,0,nextCanvas.width,nextCanvas.height);
  if (!next) return;
  const size = 16, offsetX = 8, offsetY=8;
  const shape = TETROMINOES[next][0];
  for (let b of shape){
    nctx.fillStyle = COLORS[next];
    nctx.fillRect(offsetX + b[0]*size, offsetY + b[1]*size, size-2, size-2);
  }
}

// Game loop
function loop(time=0){
  if (!running){ render(); return; }
  const delta = time - lastTime;
  lastTime = time;
  dropTimer += delta;
  if (!paused && dropTimer > dropInterval){
    stepDrop();
    dropTimer = 0;
  }
  render();
  requestAnimationFrame(loop);
}

// Input handling
document.addEventListener('keydown', (e)=>{
  if (!running) return;
  if (e.key==='ArrowLeft') move(-1);
  if (e.key==='ArrowRight') move(1);
  if (e.key==='ArrowDown') { stepDrop(); score+=1; } // soft drop
  if (e.key===' ') { e.preventDefault(); hardDrop(); score+=2; }
  if (e.key==='ArrowUp') rotate(1);
  if (e.key.toLowerCase()==='p') togglePause();
});

// Mobile buttons
document.getElementById('leftBtn')?.addEventListener('touchstart', ()=>{ move(-1); });
document.getElementById('rightBtn')?.addEventListener('touchstart', ()=>{ move(1); });
document.getElementById('downBtn')?.addEventListener('touchstart', ()=>{ stepDrop(); score+=1; });
document.getElementById('rotateBtn')?.addEventListener('touchstart', ()=>{ rotate(1); });
document.getElementById('dropBtn')?.addEventListener('touchstart', ()=>{ hardDrop(); score+=2; });

// UI buttons
document.getElementById('startBtn').addEventListener('click', ()=>{ startGame(); });
document.getElementById('pauseBtn').addEventListener('click', ()=>{ togglePause(); });
document.getElementById('toggleSound').addEventListener('click', (e)=>{ soundOn = !soundOn; e.target.textContent = soundOn? 'Sound On':'Sound Off'; });

function startGame(){
  grid = makeEmptyGrid();
  score=0; level=1; lines=0; dropInterval=800; dropTimer=0; lastTime=0;
  next = randPiece();
  spawnPiece();
  running = true; paused=false;
  requestAnimationFrame(loop);
}

function togglePause(){
  if (!running) return;
  paused = !paused;
  document.getElementById('pauseBtn').textContent = paused? 'Resume' : 'Pause';
}

// touch drag for mobile: simple left/right swipe & tap rotate
let touchStartX=0, touchStartY=0, touchMoved=false;
canvas.addEventListener('touchstart', (e)=>{
  const t = e.touches[0]; touchStartX = t.clientX; touchStartY = t.clientY; touchMoved=false;
});
canvas.addEventListener('touchmove', (e)=>{ touchMoved=true; });
canvas.addEventListener('touchend', (e)=>{
  if (!running) return;
  if (!touchMoved){
    rotate(1); return;
  }
  const t = e.changedTouches[0];
  const dx = t.clientX - touchStartX, dy = t.clientY - touchStartY;
  if (Math.abs(dx) > Math.abs(dy)){
    if (dx > 20) move(1); else if (dx < -20) move(-1);
  } else {
    if (dy > 20) stepDrop();
  }
});

// Start paused until user clicks New Game
render();
</script>
</body>
</html>
